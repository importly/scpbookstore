"""
This type stub file was generated by pyright.
"""

MODE_NUMBER = ...
MODE_ALPHA_NUM = ...
MODE_8BIT_BYTE = ...
MODE_KANJI = ...
MODE_SIZE_SMALL = ...
MODE_SIZE_MEDIUM = ...
MODE_SIZE_LARGE = ...
ALPHA_NUM = ...
RE_ALPHA_NUM = ...
NUMBER_LENGTH = ...
PATTERN_POSITION_TABLE = ...
G15 = ...
G18 = ...
G15_MASK = ...
PAD0 = ...
PAD1 = ...
_data_count = ...
BIT_LIMIT_TABLE = ...
def BCH_type_info(data):
    ...

def BCH_type_number(data):
    ...

def BCH_digit(data): # -> int:
    ...

def pattern_position(version): # -> list[int]:
    ...

def mask_func(pattern): # -> ((i: Unknown, j: Unknown) -> Unknown) | ((i: Unknown, j: Unknown) -> bool):
    """
    Return the mask function for the given mask pattern.
    """
    ...

def mode_sizes_for_version(version): # -> dict[int, int]:
    ...

def length_in_bits(mode, version): # -> int:
    ...

def check_version(version): # -> None:
    ...

def lost_point(modules): # -> int:
    ...

def optimal_data_chunks(data, minimum=...): # -> Generator[QRData, None, None]:
    """
    An iterator returning QRData chunks optimized to the data content.

    :param minimum: The minimum number of bytes in a row to split as a chunk.
    """
    ...

def to_bytestring(data): # -> bytes:
    """
    Convert data to a (utf-8 encoded) byte-string if it isn't a byte-string
    already.
    """
    ...

def optimal_mode(data): # -> int:
    """
    Calculate the optimal mode for this chunk of data.
    """
    ...

class QRData:
    """
    Data held in a QR compatible format.

    Doesn't currently handle KANJI.
    """
    def __init__(self, data, mode=..., check_data=...) -> None:
        """
        If ``mode`` isn't provided, the most compact QR data type possible is
        chosen.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def write(self, buffer): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class BitBuffer:
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get(self, index):
        ...
    
    def put(self, num, length): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def put_bit(self, bit): # -> None:
        ...
    


def create_bytes(buffer, rs_blocks): # -> list[None]:
    ...

def create_data(version, error_correction, data_list): # -> list[None]:
    ...

